{"version":3,"file":"index.mjs","sources":["../lib/base.js","../lib/iladlr.js","../lib/main.js","../lib/ndarray.js","../lib/index.js","../1e1cf38cc8d0235f27dbd8436a3ec4"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray-base-assert-is-row-major';\n\n\n// MAIN //\n\n/**\n* Returns the index of the last non-zero row in a matrix `A`.\n*\n* ## Notes\n*\n* -   If provided an empty matrix or a matrix containing only zeros, the function returns `-1` (i.e., an invalid index).\n*\n* @private\n* @param {PositiveInteger} M - number of rows in `A`\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @returns {integer} index of the last non-zero row\n*\n* @example\n* import Float64array from '@stdlib/array-float64';\n*\n* var A = new Float64array( [ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n*\n* var out = iladlr( 3, 2, A, 2, 1, 0 );\n* // returns 1\n*\n* @example\n* import Float64array from '@stdlib/array-float64';\n*\n* var A = new Float64array( [ 1.0, 3.0, 0.0, 2.0, 4.0, 0.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n*\n* var out = iladlr( 3, 2, A, 1, 3, 0 );\n* // returns 1\n*/\nfunction iladlr( M, N, A, strideA1, strideA2, offsetA ) {\n\tvar last;\n\tvar da0;\n\tvar da1;\n\tvar S0;\n\tvar S1;\n\tvar ia;\n\tvar i0;\n\tvar i1;\n\tvar k;\n\n\t// Check whether the matrix is an empty matrix...\n\tif ( M <= 0 || N <= 0 ) {\n\t\treturn -1;\n\t}\n\t// Compute the index of the first element in the last row:\n\tia = offsetA + ( (M-1) * strideA1 );\n\n\t// Compute the index offset for the last element in the last row:\n\tlast = ( N-1 ) * strideA2;\n\n\t// Check for the common case where the first and last elements in the last row are non-zero...\n\tif ( A[ ia ] !== 0.0 || A[ ia+last ] !== 0.0 ) {\n\t\treturn M - 1;\n\t}\n\t// Search for the last row containing at least one non-zero element...\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tS0 = N;\n\t\tS1 = M;\n\n\t\t// Resolve loop offset (pointer) increments:\n\t\tda0 = strideA2;\n\t\tda1 = strideA1 - ( S0*strideA2 );\n\n\t\t// Scan a row-major linear buffer from the last indexed element to the first indexed element, always moving in the same direction when both strides are the same sign, thus ensuring cache optimal traversal...\n\t\tia += last;\n\t\tfor ( i1 = S1-1; i1 >= 0; i1-- ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tif ( A[ ia ] !== 0.0 ) {\n\t\t\t\t\t// We found a row with a non-zero element!\n\t\t\t\t\treturn i1;\n\t\t\t\t}\n\t\t\t\tia -= da0;\n\t\t\t}\n\t\t\tia -= da1;\n\t\t}\n\t\t// If we've made it here, then all entries in the matrix are zero:\n\t\treturn -1;\n\t}\n\t// Column-major...\n\tS0 = M;\n\tS1 = N;\n\n\t// Resolve loop offset (pointer) increments:\n\tda0 = strideA1;\n\tda1 = strideA2;\n\n\t// Compute the index offset for the last element in each row:\n\tlast = offsetA + ( (S0-1)*da0 );\n\n\t// Initialize an index of the last row in which a non-zero element was seen:\n\tk = -1;\n\n\t// Finding the last non-zero row when a matrix is stored in column-major order requires effectively performing a full linear scan. In order to ensure cache-efficient traversal, scan up each column (otherwise, if we went row-by-row, we'd hop around linear memory, resulting in poor cache behavior)...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t// Reset the pointer to point to the last element in the current column:\n\t\tia = last + ( i1*da1 );\n\n\t\t// Scan up the rows in a column looking for a non-zero element...\n\t\tfor ( i0 = S0-1; i0 > k; i0-- ) { // note: `k` serves as a lower row index bound, thus shrinking the number of rows we need to check when scanning columns\n\t\t\tif ( A[ ia ] !== 0.0 ) {\n\t\t\t\t// We found a non-zero element, which means we no longer have to search this row...\n\t\t\t\tk = i0;\n\t\t\t\tbreak; // note: in principle, if `k == M-1`, we could early return; however, this is a hot loop and adding an additional conditional is likely to degrade average performance in order to cater to what is effectively an edge case\n\t\t\t}\n\t\t\tia -= da0;\n\t\t}\n\t}\n\treturn k;\n}\n\n\n// EXPORTS //\n\nexport default iladlr;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas-base-assert-is-layout';\nimport isRowMajor from '@stdlib/ndarray-base-assert-is-row-major-string';\nimport isColumnMajor from '@stdlib/ndarray-base-assert-is-column-major-string';\nimport max from '@stdlib/math-base-special-fast-max';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Returns the index of the last non-zero row in a matrix `A`.\n*\n* @param {string} order - storage layout\n* @param {PositiveInteger} M - number of rows in `A`\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} fifth argument must be greater than or equal to max(1,N)\n* @returns {integer} index of the last non-zero row\n*\n* @example\n* import Float64array from '@stdlib/array-float64';\n*\n* var A = new Float64array( [ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n*\n* var out = iladlr( 'row-major', 3, 2, A, 2 );\n* // returns 1\n*/\nfunction iladlr( order, M, N, A, LDA ) {\n\tvar sa1;\n\tvar sa2;\n\tvar s;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isRowMajor( order ) ) {\n\t\ts = N;\n\t} else {\n\t\ts = M;\n\t}\n\tif ( LDA < max( 1, s ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fifth argument must be greater than or equal to max(1,%d). Value: `%d`.', s, LDA ) );\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( M, N, A, sa1, sa2, 0 );\n}\n\n\n// EXPORTS //\n\nexport default iladlr;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport iladlr from './iladlr.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( iladlr, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default iladlr;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Returns the index of the last non-zero row in a matrix `A` using alternative indexing semantics.\n*\n* @param {PositiveInteger} M - number of rows in `A`\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Float64Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @returns {integer} index of the last non-zero row\n*\n* @example\n* import Float64array from '@stdlib/array-float64';\n*\n* var A = new Float64array( [ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n*\n* var out = iladlr( 3, 2, A, 2, 1, 0 );\n* // returns 1\n*/\nfunction iladlr( M, N, A, strideA1, strideA2, offsetA ) {\n\treturn base( M, N, A, strideA1, strideA2, offsetA );\n}\n\n\n// EXPORTS //\n\nexport default iladlr;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to find the index of the last non-zero row in a input matrix.\n*\n* @module @stdlib/lapack-base-iladlr\n*\n* @example\n* import Float64array from '@stdlib/array-float64';\n* import iladlr from '@stdlib/lapack-base-iladlr';\n*\n* var A = new Float64array( [ 1.0, 2.0, 3.0, 4.0, 0.0, 0.0 ] ); // => [ [ 1.0, 2.0 ], [ 3.0, 4.0 ], [ 0.0, 0.0 ] ]\n*\n* var out = iladlr( 'row-major', 3, 2, A, 2 );\n* // returns 1\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils-try-require';\nimport isError from '@stdlib/assert-is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar iladlr;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tiladlr = main;\n} else {\n\tiladlr = tmp;\n}\n\n\n// EXPORTS //\n\nexport default iladlr;\n","export default '/home/runner/work/lapack-base-iladlr/lapack-base-iladlr/lib'"],"names":["iladlr","M","N","A","strideA1","strideA2","offsetA","last","da0","da1","S0","S1","ia","i0","i1","k","isRowMajor","order","LDA","sa1","sa2","s","isLayout","TypeError","format","max","RangeError","isColumnMajor","base","setReadOnly","tmp","tryRequire","join","require$$0","iladlr$1","isError","main"],"mappings":";;i3GA2DA,SAASA,EAAQC,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,GAC7C,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAGJ,GAAKd,GAAK,GAAKC,GAAK,EACnB,OAAQ,EAST,GAHAK,GAASL,EAAE,GAAMG,EAGA,IAAZF,EANLS,EAAKN,GAAaL,EAAE,GAAKG,IAMgB,IAAjBD,EAAGS,EAAGL,GAC7B,OAAON,EAAI,EAGZ,GAAKe,EAAY,CAAEZ,EAAUC,IAAe,CAU3C,IALAG,EAAMH,EACNI,EAAML,GALNM,EAAKR,GAKiBG,EAGtBO,GAAML,EACAO,GARNH,EAAKV,GAQS,EAAGa,GAAM,EAAGA,IAAO,CAChC,IAAMD,EAAK,EAAGA,EAAKH,EAAIG,IAAO,CAC7B,GAAiB,IAAZV,EAAGS,GAEP,OAAOE,EAERF,GAAMJ,CACN,CACDI,GAAMH,CACN,CAED,OAAQ,CACR,CAgBD,IAbAE,EAAKT,EAILO,EAAMJ,EAGNE,EAAOD,IARPI,EAAKT,GAQkB,IAJvBO,EAAMJ,GAONW,GAAK,EAGCD,EAAK,EAAGA,EAAKH,EAAIG,IAKtB,IAHAF,EAAKL,EAASO,EAAGL,EAGXI,EAAKH,EAAG,EAAGG,EAAKE,EAAGF,IAAO,CAC/B,GAAiB,IAAZV,EAAGS,GAAe,CAEtBG,EAAIF,EACJ,KACA,CACDD,GAAMJ,CACN,CAEF,OAAOO,CACR,CCtFA,SAASf,EAAQiB,EAAOhB,EAAGC,EAAGC,EAAGe,GAChC,IAAIC,EACAC,EACAC,EACJ,IAAMC,EAAUL,GACf,MAAM,IAAIM,UAAWC,EAAQ,uEAAwEP,IAOtG,GAJCI,EADIL,EAAYC,GACZf,EAEAD,EAEAiB,EAAMO,EAAK,EAAGJ,GAClB,MAAM,IAAIK,WAAYF,EAAQ,4FAA6FH,EAAGH,IAS/H,OAPKS,EAAeV,IACnBE,EAAM,EACNC,EAAMF,IAENC,EAAMD,EACNE,EAAM,GAEAQ,EAAM3B,EAAGC,EAAGC,EAAGgB,EAAKC,EAAK,EACjC,CC9CAS,EAAA7B,EAAA,WCiBA,SAAiBC,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,GAC7C,OAAOsB,EAAM3B,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAC3C,ICXA,IASIwB,EAAMC,GAAYC,EATXC,EAAkBD,MCrCd,8DD8CwB,gBAUvCE,EATKC,EAASL,GACJM,EAEAN"}